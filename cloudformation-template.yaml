AWSTemplateFormatVersion: '2010-09-09'
Description: 'Multitenant JSON Block Builder Infrastructure'

Parameters:
  Environment:
    Type: String
    Default: dev
    Description: Environment name
  DeploymentId:
    Type: String
    Default: v1
    Description: Unique identifier to force API redeploy (e.g., timestamp)
  DomainName:
    Type: String
    Default: blockforger.net
    Description: Base domain name for tenants
  HostedZoneId:
    Type: String
    Default: Z02099242KCFS792PXWP
    Description: Route 53 Hosted Zone ID for blockforger.net
  EC2KeyName:
    Type: String
    Default: Json-Blockbuilder-MVP-keypair
    Description: EC2 Key Pair name for SSH access
  MyVPC:
    Type: String
    Default: vpc-fc7ecc86
    Description: VPC ID
  OpenAIApiKey:
    Type: String
    NoEcho: true
    Description: OpenAI API Key for LLM schema generation
  GoogleClientId:
    Type: String
    NoEcho: true
    Description: Google OAuth 2.0 Client ID
  GoogleClientSecret:
    Type: String
    NoEcho: true
    Description: Google OAuth 2.0 Client Secret
  StripeSecretKey:
    Type: String
    NoEcho: true
    Description: Stripe Secret Key for billing integration
  StripeWebhookSecret:
    Type: String
    NoEcho: true
    Description: Stripe Webhook Secret for webhook verification
  ExistingS3BucketArn:
    Type: String
    Default: arn:aws:s3:::universal-frontend-720291373173-dev
    Description: ARN of existing S3 bucket for schemas and static files
  ExistingFrontendUsersTableArn:
    Type: String
    Default: arn:aws:dynamodb:us-east-1:720291373173:table/frontend-users
    Description: ARN of existing DynamoDB table for permissions and data of users
  ExistingBillingTableArn:
    Type: String
    Default: arn:aws:dynamodb:us-east-1:720291373173:table/billing-admins
    Description: ARN of existing DynamoDB table for billing administrators
  ExistingBillingUserFromTenantTableArn:
    Type: String
    Default: arn:aws:dynamodb:us-east-1:720291373173:table/billinguser-from-tenant-dev
    Description: ARN of existing DynamoDB table for tenant-to-user mapping
  ExistingLambdaDeploymentBucket:
    Type: String
    Default: lambda-deployment-720291373173-dev
    Description: S3 bucket name for Lambda deployment package
  ExistingLambdaDeploymentKey:
    Type: String
    Default: lambda-deployment-dev.zip
    Description: S3 key (filename) for Lambda deployment package
  ExistingS3BucketName:
    Type: String
    Default: universal-frontend-720291373173-dev
    Description: S3 bucket name for schemas and static files (extracted from ARN)
  StripeInitialPaymentUrl:
    Type: String
    Description: Stripe initial payment URL for token packages
    Default: https://buy.stripe.com/test_28E14n7945li2ttcuQ8so02
  StripeCustomerPortalUrl:
    Type: String
    Description: Stripe Customer Portal URL
    Default: https://billing.stripe.com/p/login/test_00weVd50W8xu3xx8eA8so00
  StripeProductId:
    Type: String
    Description: Stripe Product ID
    Default: prod_TGV0TTpa3D6MJc
  ScaleUpThreshold:
    Type: Number
    Description: 'CPU threshold for scaling up'
    Default: 85
  ScaleDownThreshold:
    Type: Number
    Description: 'CPU threshold for scaling down'
    Default: 20
  PaymentEnforced:
    Type: String
    Description: 'Enforce payment requirements - return 402 errors when insufficient tokens (true/false)'
    Default: 'false'
    AllowedValues: ['true', 'false']
  BillingPasskey:
    Type: String
    NoEcho: true
    Description: 'Secret passkey for authorizing daily billing operations'
  BillingPasskeyHash:
    Type: String
    Description: 'SHA256 hash of the billing passkey for verification'
    Default: '637bd84aa3aeff1bc73f4187fa438951d0e763bead8fad9df2b58aedf8e3c24b'

Resources:
  # ============================================================================
  # TWO-PHASE PROD DEPLOYMENT INSTRUCTIONS:
  # 
  # STAGE 1: Create prod resources
  #   1. Uncomment all resources in "STAGE 1: PROD RESOURCES" section below
  #   2. Deploy the stack - this will create:
  #      - universal-frontend-720291373173-prod (S3 bucket)
  #      - lambda-deployment-720291373173-prod (S3 bucket)
  #      - frontend-users-prod (DynamoDB table)
  #      - billing-admins-prod (DynamoDB table)
  #      - billinguser-from-tenant-prod (DynamoDB table)
  #   3. Copy select data from dev resources for smoke testing
  #   
  # STAGE 2: Untrack resources from CloudFormation
  #   1. Recomment all "STAGE 1: PROD RESOURCES" resources (leave them commented)
  #   2. Update parameter defaults or override with prod values:
  #      - ExistingS3BucketArn: arn:aws:s3:::universal-frontend-720291373173-prod
  #      - ExistingS3BucketName: universal-frontend-720291373173-prod
  #      - ExistingFrontendUsersTableArn: arn:aws:dynamodb:us-east-1:720291373173:table/frontend-users-prod
  #      - ExistingBillingTableArn: arn:aws:dynamodb:us-east-1:720291373173:table/billing-admins-prod
  #      - ExistingBillingUserFromTenantTableArn: arn:aws:dynamodb:us-east-1:720291373173:table/billinguser-from-tenant-prod
  #      - ExistingLambdaDeploymentBucket: lambda-deployment-720291373173-prod
  #   3. Deploy again - resources are now referenced by ARN only, not tracked in CFT
  # ============================================================================
  
  # ============================================================================
  # STAGE 1: PROD RESOURCES - COMMENTED OUT FOR INITIAL CREATION
  # Uncomment these for Stage 1 deployment, then recomment for Stage 2
  # ============================================================================
  
  #S3 Bucket for schemas and static files (PROD)
  # FrontendS3BucketProd:
  #   Type: AWS::S3::Bucket
  #   Properties:
  #     BucketName: universal-frontend-720291373173-prod
  #     VersioningConfiguration:
  #       Status: Enabled
  #     Tags:
  #       - Key: Environment
  #         Value: prod
  #       - Key: Purpose
  #         Value: Frontend schemas and static files

  #S3 Bucket for Lambda deployment (PROD)
  # LambdaDeploymentBucketProd:
  #   Type: AWS::S3::Bucket
  #   Properties:
  #     BucketName: lambda-deployment-720291373173-prod
  #     VersioningConfiguration:
  #       Status: Enabled
  #     Tags:
  #       - Key: Environment
  #         Value: prod
  #       - Key: Purpose
  #         Value: Lambda deployment packages

  #DynamoDB Table for user management (PROD)
  # FrontendUsersTableProd:
  #   Type: AWS::DynamoDB::Table
  #   Properties:
  #     TableName: frontend-users-prod
  #     KeySchema:
  #       - AttributeName: tenantId
  #         KeyType: HASH
  #       - AttributeName: user_email
  #         KeyType: RANGE
  #     AttributeDefinitions:
  #       - AttributeName: tenantId
  #         AttributeType: S
  #       - AttributeName: user_email
  #         AttributeType: S
  #     BillingMode: PAY_PER_REQUEST
  #     Tags:
  #       - Key: Environment
  #         Value: prod
  #       - Key: Purpose
  #         Value: User management with proper composite key

  #DynamoDB Table for billing administrators (PROD)
  # BillingAdministratorsTableProd:
  #   Type: AWS::DynamoDB::Table
  #   Properties:
  #     TableName: billing-admins-prod
  #     KeySchema:
  #       - AttributeName: user_email
  #         KeyType: HASH
  #     AttributeDefinitions:
  #       - AttributeName: user_email
  #         AttributeType: S
  #       - AttributeName: stripe_customer_id
  #         AttributeType: S
  #     BillingMode: PAY_PER_REQUEST
  #     GlobalSecondaryIndexes:
  #       - IndexName: StripeCustomerIndex
  #         KeySchema:
  #           - AttributeName: stripe_customer_id
  #             KeyType: HASH
  #         Projection:
  #           ProjectionType: ALL
  #     Tags:
  #       - Key: Environment
  #         Value: prod
  #       - Key: Purpose
  #         Value: Billing administrators and token management

  #DynamoDB Table for tenant-to-user mapping (PROD)
  # BillingUserFromTenantTableDev:
  #   Type: AWS::DynamoDB::Table
  #   Properties:
  #     TableName: billinguser-from-tenant-dev
  #     # SIMPLE PRIMARY KEY: tenant_id only (maps tenant -> one user)
  #     KeySchema:
  #       - AttributeName: tenant_id
  #         KeyType: HASH
  #     AttributeDefinitions:
  #       - AttributeName: tenant_id
  #         AttributeType: S
  #       - AttributeName: user_email
  #         AttributeType: S
  #     BillingMode: PAY_PER_REQUEST
  #     # GSI to lookup by user_email when needed
  #     GlobalSecondaryIndexes:
  #       - IndexName: UserEmailIndex
  #         KeySchema:
  #           - AttributeName: user_email
  #             KeyType: HASH
  #         Projection:
  #           ProjectionType: ALL
  #     Tags:
  #       - Key: Environment
  #         Value: dev
  #       - Key: Purpose
  #         Value: Tenant-to-user mapping

  # ============================================================================
  # ORIGINAL DEV RESOURCES - REFERENCED BY ARN ONLY
  # ============================================================================
  
  # DynamoDB Table for user management - NEW TABLE with correct key structure
  #FrontendUsersTable:
    #Type: AWS::DynamoDB::Table
    #Properties:
      #TableName: frontend-users
      #KeySchema:
        #- AttributeName: tenantId
      #    KeyType: HASH
      #  - AttributeName: user_email
       #   KeyType: RANGE
      #AttributeDefinitions:
      #  - AttributeName: tenantId
       #   AttributeType: S
      #  - AttributeName: user_email
     #     AttributeType: S
     # BillingMode: PAY_PER_REQUEST
     # Tags:
     #   - Key: Environment
      #    Value: !Ref Environment
      #  - Key: Purpose
      #    Value: User management with proper composite key

  # DynamoDB Table for billing administrators - using existing table
  # BillingAdministratorsTable: Referenced by ARN parameter ExistingBillingTableArn
      # Additional attributes will be added dynamically:
      # - token_balance (Number): Current token balance for the user
      # - last_payment_date (Number): Unix timestamp of last payment
      # - last_payment_amount (Number): Amount of last payment in cents
      # - total_tokens_purchased (Number): Total tokens purchased all time
      # - account_created_date (Number): Unix timestamp when account was created

  # DynamoDB Table for tenant-to-user mapping - using existing table with deletion protection
  # BillingUserFromTenantTable: billinguser-from-tenant-dev (managed outside CloudFormation)

  # S3 Buckets removed - using existing buckets that cannot be deleted
  # All S3 bucket management is handled outside this stack

  # CloudFront removed - not using it yet

  # IAM Role for Lambda
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'json-blockbuilder-lambda-role-${Environment}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !Ref ExistingFrontendUsersTableArn
                  - !Ref ExistingBillingTableArn
                  - !Sub '${ExistingBillingTableArn}/index/StripeCustomerIndex'
                  - !Ref ExistingBillingUserFromTenantTableArn
                  - !Sub '${ExistingBillingUserFromTenantTableArn}/index/UserEmailIndex'
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                  - s3:ListBucket
                Resource:
                  - !Sub '${ExistingS3BucketArn}/*'
                  - !Sub '${ExistingS3BucketArn}'
        - PolicyName: LambdaDeploymentAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                Resource:
                  - !Sub 'arn:aws:s3:::${ExistingLambdaDeploymentBucket}/*'

  # IAM Role for Stripe Webhook Lambda
  StripeWebhookLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'stripe-webhook-lambda-role-${Environment}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
          - Effect: Allow
            Principal:
              Service: events.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: BillingDynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !Ref ExistingBillingTableArn
                  - !Sub '${ExistingBillingTableArn}/index/StripeCustomerIndex'
        - PolicyName: SQSAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - sqs:SendMessage
                  - sqs:GetQueueAttributes
                  - sqs:ReceiveMessage
                  - sqs:DeleteMessage
                  - sqs:GetQueueUrl
                Resource: !GetAtt StripeWebhookQueue.Arn

  # Lambda Function
  JsonBlockBuilderLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'json-blockbuilder-api-${Environment}'
      Runtime: python3.9
      Handler: lambda_function.lambda_handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Code:
        S3Bucket: !Ref ExistingLambdaDeploymentBucket
        S3Key: !Ref ExistingLambdaDeploymentKey
      Environment:
        Variables:
          BUCKET_NAME: !Ref ExistingS3BucketName
          BILLING_TABLE_NAME: !Select [1, !Split ['/', !Sub '${ExistingBillingTableArn}']]
          FRONTEND_USERS_TABLE_NAME: !Select [1, !Split ['/', !Sub '${ExistingFrontendUsersTableArn}']]
          BILLING_USER_FROM_TENANT_TABLE_NAME: !Select [1, !Split ['/', !Sub '${ExistingBillingUserFromTenantTableArn}']]
          OPENAI_API_KEY: !Ref OpenAIApiKey
          GOOGLE_CLIENT_ID: !Ref GoogleClientId
          GOOGLE_CLIENT_SECRET: !Ref GoogleClientSecret
          STRIPE_SECRET_KEY: !Ref StripeSecretKey
          STRIPE_WEBHOOK_SECRET: !Ref StripeWebhookSecret
          STRIPE_INITIAL_PAYMENT_URL: !Ref StripeInitialPaymentUrl
          STRIPE_CUSTOMER_PORTAL_URL: !Ref StripeCustomerPortalUrl
          STRIPE_PRODUCT_ID: !Ref StripeProductId
          PAYMENT_ENABLED: !Ref PaymentEnforced
          BILLING_PASSKEY_HASH: !Ref BillingPasskeyHash
      Timeout: 30

  # Stripe Webhook Processing Lambda Function
  StripeWebhookLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub 'stripe-webhook-processor-${Environment}'
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt StripeWebhookLambdaRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          from decimal import Decimal
          from datetime import datetime
          
          # Initialize AWS clients
          import os
          dynamodb = boto3.resource('dynamodb')
          billing_table_name = os.environ.get('BILLING_TABLE_NAME', 'billing-admins')
          billing_table = dynamodb.Table(billing_table_name)
          
          def lambda_handler(event, context):
              print("=" * 50)
              print("STRIPE WEBHOOK LAMBDA STARTED")
              print("=" * 50)
              print(f"Full event received: {json.dumps(event, indent=2)}")
              print(f"Event keys: {list(event.keys())}")
              
              try:
                  # Check if this is an SQS event (all events now come through SQS)
                  if 'Records' in event and len(event['Records']) > 0:
                      print("✅ SQS event detected")
                      return handle_sqs_event(event)
                  else:
                      print("❌ Not an SQS event")
                      print(f"Event keys: {list(event.keys())}")
                      return {'statusCode': 200, 'body': 'Event not from SQS'}

              except Exception as e:
                  print(f"💥 ERROR processing webhook: {str(e)}")
                  import traceback
                  print(f"Traceback: {traceback.format_exc()}")
                  return {'statusCode': 500, 'body': f'Error: {str(e)}'}
          
          def handle_sqs_event(event):
              """Handle SQS events from EventBridge"""
              print("=" * 30)
              print("HANDLING SQS EVENT FROM EVENTBRIDGE")
              print("=" * 30)
              
              try:
                  # Process each record in the SQS event
                  for record in event.get('Records', []):
                      print(f"Processing SQS record: {json.dumps(record, indent=2)}")
                      
                      # Extract the Stripe event from the SQS message body
                      if 'body' in record:
                          try:
                              # Parse the SQS message body (now contains EventBridge event directly)
                              eventbridge_event = json.loads(record['body'])
                              print(f"Parsed EventBridge event: {json.dumps(eventbridge_event, indent=2)}")
                              
                              # Extract the Stripe event from the EventBridge event detail
                              if 'detail' in eventbridge_event:
                                  stripe_event = eventbridge_event['detail']
                                  event_type = stripe_event.get('type')
                                  
                                  print(f"Processing Stripe event type: {event_type}")
                                  
                                  # Process the event based on type using existing handlers
                                  if event_type == 'checkout.session.completed':
                                      result = handle_checkout_completed(stripe_event)
                                      print(f"Checkout completed result: {result}")
                                  elif event_type == 'checkout.session.async_payment_succeeded':
                                      result = handle_checkout_succeeded(stripe_event)
                                      print(f"Checkout succeeded result: {result}")
                                  elif event_type == 'checkout.session.async_payment_failed':
                                      result = handle_checkout_failed(stripe_event)
                                      print(f"Checkout failed result: {result}")
                                  elif event_type == 'checkout.session.expired':
                                      result = handle_checkout_expired(stripe_event)
                                      print(f"Checkout expired result: {result}")
                                  else:
                                      print(f"Unhandled event type: {event_type}")
                              else:
                                  print("No detail section found in EventBridge event")
                                      
                          except json.JSONDecodeError as e:
                              print(f"Failed to parse SQS message body: {e}")
                              print(f"Raw message body: {record['body']}")
                      else:
                          print("No body found in SQS record")
                          
                  return {
                      'statusCode': 200,
                      'body': json.dumps({'message': 'SQS processing completed'})
                  }
                  
              except Exception as e:
                  print(f"Error processing SQS event: {str(e)}")
                  import traceback
                  print(f"Traceback: {traceback.format_exc()}")
                  return {
                      'statusCode': 500,
                      'body': json.dumps({'error': 'SQS processing failed'})
                  }
          
          def handle_checkout_completed(stripe_event):
              """Handle successful checkout completion"""
              print("=" * 30)
              print("HANDLING CHECKOUT COMPLETED")
              print("=" * 30)
              
              try:
                  session = stripe_event['data']['object']
                  print(f"Session data: {json.dumps(session, indent=2)}")
                  
                  # Use amount_subtotal instead of amount_total
                  amount_subtotal = session.get('amount_subtotal', 0)  # Amount in cents
                  print(f"Amount subtotal: {amount_subtotal} cents")
                  
                  # Convert amount to tokens (300 tokens per cent)
                  tokens_purchased = amount_subtotal * 300  # 300 tokens per cent
                  print(f"Tokens to credit: {tokens_purchased} (300 tokens per cent)")
                  
                  print(f"Processing payment for {tokens_purchased} tokens, amount: ${amount_subtotal/100}")
                  
                  # Get user email from customer_details.email (this is the correct field)
                  customer_details = session.get('customer_details', {})
                  print(f"Customer details: {json.dumps(customer_details, indent=2)}")
                  
                  user_email = customer_details.get('email')
                  print(f"User email extracted: {user_email}")
                  
                  if not user_email:
                      print("❌ ERROR: No customer email found in checkout session")
                      print(f"Full session data: {json.dumps(session, indent=2)}")
                      return {'statusCode': 400, 'body': 'No customer email found'}
                  
                  print(f"✅ Crediting {tokens_purchased} tokens to {user_email}")
                  
                  # Get customer ID, only set if not empty
                  customer_id = session.get('customer', '')
                  print(f"Stripe customer ID: {customer_id}")
                  
                  # Get current timestamp for account creation and last activity
                  import time
                  current_timestamp = int(time.time())
                  current_iso = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.%f')
                  
                  # Check if user already exists
                  try:
                      existing = billing_table.get_item(Key={'user_email': user_email})
                      user_exists = 'Item' in existing
                  except Exception as e:
                      print(f"Error checking existing user: {e}")
                      user_exists = False
                  
                  # Prepare DynamoDB update/create with all required fields
                  if user_exists:
                      # Update existing user
                      if customer_id:
                          update_expression = 'SET token_balance = if_not_exists(token_balance, :zero) + :tokens, total_tokens_purchased = if_not_exists(total_tokens_purchased, :zero) + :tokens, last_payment_date = :date, last_payment_amount = :amount, last_activity = :activity, stripe_customer_id = :customer_id'
                          expression_values = {
                              ':tokens': Decimal(str(tokens_purchased)),
                              ':zero': Decimal('0'),
                              ':date': Decimal(str(stripe_event['created'])),
                              ':amount': Decimal(str(amount_subtotal)),
                              ':activity': current_iso,
                              ':customer_id': customer_id
                          }
                      else:
                          update_expression = 'SET token_balance = if_not_exists(token_balance, :zero) + :tokens, total_tokens_purchased = if_not_exists(total_tokens_purchased, :zero) + :tokens, last_payment_date = :date, last_payment_amount = :amount, last_activity = :activity'
                          expression_values = {
                              ':tokens': Decimal(str(tokens_purchased)),
                              ':zero': Decimal('0'),
                              ':date': Decimal(str(stripe_event['created'])),
                              ':amount': Decimal(str(amount_subtotal)),
                              ':activity': current_iso
                          }
                      
                      print(f"Update expression: {update_expression}")
                      print(f"Expression values: {expression_values}")
                      
                      response = billing_table.update_item(
                          Key={'user_email': user_email},
                          UpdateExpression=update_expression,
                          ExpressionAttributeValues=expression_values,
                          ReturnValues='UPDATED_NEW'
                      )
                  else:
                      # Create new user with all required fields
                      item_data = {
                          'user_email': user_email,
                          'account_created_date': Decimal(str(stripe_event['created'])),
                          'account_status': 'active',
                          'billing_enabled': True,
                          'last_activity': current_iso,
                          'last_payment_date': Decimal(str(stripe_event['created'])),
                          'last_payment_amount': Decimal(str(amount_subtotal)),
                          'token_balance': Decimal(str(tokens_purchased)),
                          'total_tokens_purchased': Decimal(str(tokens_purchased)),
                          'created_via': 'stripe_eventbridge'
                      }
                      
                      if customer_id:
                          item_data['stripe_customer_id'] = customer_id
                      
                      print(f"Creating new user with data: {json.dumps(item_data, indent=2, default=str)}")
                      
                      response = billing_table.put_item(Item=item_data)
                      
                  print(f"✅ DynamoDB update response: {json.dumps(response, indent=2, default=str)}")
                  print(f"✅ Successfully updated token balance for {user_email}")
                  return {'statusCode': 200, 'body': f'Tokens added successfully to {user_email}'}
                  
              except Exception as e:
                  print(f"💥 ERROR handling checkout completed: {str(e)}")
                  import traceback
                  print(f"Traceback: {traceback.format_exc()}")
                  return {'statusCode': 500, 'body': f'Error: {str(e)}'}
          
          def handle_checkout_succeeded(stripe_event):
              """Handle async payment success"""
              return handle_checkout_completed(stripe_event)
          
          def handle_checkout_failed(stripe_event):
              """Handle payment failure"""
              try:
                  session = stripe_event['data']['object']
                  customer_email = session.get('customer_details', {}).get('email')
                  
                  print(f"Payment failed for {customer_email}")
                  
                  # Could log failure or send notification
                  return {'statusCode': 200, 'body': 'Payment failure logged'}
                  
              except Exception as e:
                  print(f"Error handling checkout failed: {str(e)}")
                  return {'statusCode': 500, 'body': f'Error: {str(e)}'}
          
          def handle_checkout_expired(stripe_event):
              """Handle session expiration"""
              try:
                  session = stripe_event['data']['object']
                  customer_email = session.get('customer_details', {}).get('email')
                  
                  print(f"Checkout session expired for {customer_email}")
                  
                  # Could log expiration or send notification
                  return {'statusCode': 200, 'body': 'Session expiration logged'}
                  
              except Exception as e:
                  print(f"Error handling checkout expired: {str(e)}")
                  return {'statusCode': 500, 'body': f'Error: {str(e)}'}
      Environment:
        Variables:
          # No Stripe API key needed - we only process EventBridge events
          ENVIRONMENT: !Ref Environment
          BILLING_TABLE_NAME: !Select [1, !Split ['/', !Sub '${ExistingBillingTableArn}']]
      Timeout: 30

  # API Gateway
  ApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: !Sub 'json-blockbuilder-api-${Environment}'
      Description: API Gateway for JSON Block Builder Lambda

  # Global Gateway Responses to add CORS headers on errors
  ApiGatewayResponseDefault4XX:
    Type: AWS::ApiGateway::GatewayResponse
    Properties:
      RestApiId: !Ref ApiGateway
      ResponseType: DEFAULT_4XX
      ResponseParameters:
        gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
        gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
        gatewayresponse.header.Access-Control-Allow-Methods: "'GET,POST,OPTIONS,PUT,DELETE'"

  ApiGatewayResponseDefault5XX:
    Type: AWS::ApiGateway::GatewayResponse
    Properties:
      RestApiId: !Ref ApiGateway
      ResponseType: DEFAULT_5XX
      ResponseParameters:
        gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
        gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
        gatewayresponse.header.Access-Control-Allow-Methods: "'GET,POST,OPTIONS,PUT,DELETE'"

  ApiGatewayResponseUnauthorized:
    Type: AWS::ApiGateway::GatewayResponse
    Properties:
      RestApiId: !Ref ApiGateway
      ResponseType: UNAUTHORIZED
      ResponseParameters:
        gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
        gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
        gatewayresponse.header.Access-Control-Allow-Methods: "'GET,POST,OPTIONS,PUT,DELETE'"

  ApiGatewayResponseAccessDenied:
    Type: AWS::ApiGateway::GatewayResponse
    Properties:
      RestApiId: !Ref ApiGateway
      ResponseType: ACCESS_DENIED
      ResponseParameters:
        gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
        gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
        gatewayresponse.header.Access-Control-Allow-Methods: "'GET,POST,OPTIONS,PUT,DELETE'"

  ApiGatewayResponseMissingAuthToken:
    Type: AWS::ApiGateway::GatewayResponse
    Properties:
      RestApiId: !Ref ApiGateway
      ResponseType: MISSING_AUTHENTICATION_TOKEN
      ResponseParameters:
        gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
        gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
        gatewayresponse.header.Access-Control-Allow-Methods: "'GET,POST,OPTIONS,PUT,DELETE'"

  ApiGatewayResourceApi:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !GetAtt ApiGateway.RootResourceId
      PathPart: 'api'

  # ----------- Child Resources -----------
  ApiGatewayResourceDel:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'del'

  ApiGatewayResourceJson:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'json'

  ApiGatewayResourceAuth:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'auth'

  ApiGatewayResourceLlm:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'llm'

  ApiGatewayResourceLlmPreload:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'llm-preload'

  ApiGatewayResourceRegister:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'register'

  ApiGatewayResourceDeleteTenant:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'admin_delete'

  ApiGatewayResourceCreateUser:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'create_user'

  ApiGatewayResourceManageOAuthScopes:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'manage_oauth_scopes'

  ApiGatewayResourceOAuthTokenExchange:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'oauth_token_exchange'

  ApiGatewayResourceCheckAccountStatus:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'check_account_status'

  # ApiGatewayResourceBill removed - not exposed publicly

  ApiGatewayResourceDebitTokens:
    Type: AWS::ApiGateway::Resource
    Properties:
      RestApiId: !Ref ApiGateway
      ParentId: !Ref ApiGatewayResourceApi
      PathPart: 'debit_tokens'

  # ----------- Methods -----------
  ApiMethodApiOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceApi
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true
  ApiMethodDel:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceDel
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "del",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Headers: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,OPTIONS,PUT,DELETE'"
            ResponseTemplates:
              application/json: '$input.path("$.body")'
          - StatusCode: 400
            SelectionPattern: '4[0-9][0-9]'
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Headers: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,OPTIONS,PUT,DELETE'"
            ResponseTemplates:
              application/json: '$input.path("$.body")'
          - StatusCode: 500
            SelectionPattern: '5[0-9][0-9]'
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Headers: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,OPTIONS,PUT,DELETE'"
            ResponseTemplates:
              application/json: '$input.path("$.body")'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
        - StatusCode: 400
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
        - StatusCode: 500
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true

  ApiMethodDelOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceDel
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  ApiMethodJson:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceJson
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "json",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Headers: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,OPTIONS,PUT,DELETE'"
          - StatusCode: 400
            SelectionPattern: '4[0-9][0-9]'
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Headers: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,OPTIONS,PUT,DELETE'"
          - StatusCode: 500
            SelectionPattern: '5[0-9][0-9]'
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Headers: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'GET,POST,OPTIONS,PUT,DELETE'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
        - StatusCode: 400
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true
        - StatusCode: 500
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Allow-Methods: true

  ApiMethodJsonOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceJson
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  ApiMethodAuth:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceAuth
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "auth",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodAuthOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceAuth
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  ApiMethodLlm:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceLlm
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "llm",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodLlmOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceLlm
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  ApiMethodLlmPreload:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceLlmPreload
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "llm-preload",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodLlmPreloadOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceLlmPreload
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  ApiMethodRegister:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceRegister
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "register",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodRegisterOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceRegister
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  ApiMethodDeleteTenant:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceDeleteTenant
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        Credentials: !GetAtt ApiGatewayExecutionRole.Arn
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "admin_delete",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodDeleteTenantOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceDeleteTenant
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  ApiMethodCreateUser:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceCreateUser
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        Credentials: !GetAtt ApiGatewayExecutionRole.Arn
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "create_user",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodCreateUserOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceCreateUser
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  ApiMethodManageOAuthScopes:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceManageOAuthScopes
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "manage_oauth_scopes",
              "body": $input.json('$.body'),
              "headers": {
                #foreach($header in $input.params().header.keySet())
                "$header": "$util.escapeJavaScript($input.params().header.get($header))"#if($foreach.hasNext),#end
                #end
              }
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodManageOAuthScopesOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceManageOAuthScopes
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  ApiMethodOAuthTokenExchange:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceOAuthTokenExchange
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "oauth_token_exchange",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodOAuthTokenExchangeOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceOAuthTokenExchange
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  # Check Account Status Method
  ApiMethodCheckAccountStatus:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceCheckAccountStatus
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "check_account_status",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodCheckAccountStatusOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceCheckAccountStatus
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true


  # Debit Tokens Method
  ApiMethodDebitTokens:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceDebitTokens
      HttpMethod: POST
      AuthorizationType: NONE
      Integration:
        Type: AWS
        IntegrationHttpMethod: POST
        Uri: !Sub 'arn:aws:apigateway:${AWS::Region}:lambda:path/2015-03-31/functions/${JsonBlockBuilderLambda.Arn}/invocations'
        RequestTemplates:
          application/json: |
            {
              "type": "debit_tokens",
              "body": $input.json('$.body')
            }
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true

  ApiMethodDebitTokensOptions:
    Type: AWS::ApiGateway::Method
    Properties:
      RestApiId: !Ref ApiGateway
      ResourceId: !Ref ApiGatewayResourceDebitTokens
      HttpMethod: OPTIONS
      AuthorizationType: NONE
      Integration:
        Type: MOCK
        IntegrationResponses:
          - StatusCode: 200
            ResponseParameters:
              method.response.header.Access-Control-Allow-Origin: "'*'"
              method.response.header.Access-Control-Allow-Methods: "'POST, OPTIONS'"
              method.response.header.Access-Control-Allow-Headers: "'Content-Type, Authorization, X-Amz-Date, X-Api-Key, X-Amz-Security-Token'"
              method.response.header.Access-Control-Max-Age: "'86400'"
            ResponseTemplates:
              application/json: '{"message": "CORS preflight"}'
        RequestTemplates:
          application/json: '{"statusCode": 200}'
      MethodResponses:
        - StatusCode: 200
          ResponseParameters:
            method.response.header.Access-Control-Allow-Origin: true
            method.response.header.Access-Control-Allow-Methods: true
            method.response.header.Access-Control-Allow-Headers: true
            method.response.header.Access-Control-Max-Age: true

  # REMOVED: ApiMethodSignupCallback - now handled via auth endpoint with billing field
  # REMOVED: ApiMethodSignupCallbackOptions - now handled via auth endpoint with billing field
  # REMOVED: ApiMethodBillingConfig - now using direct Stripe portal redirects
  # REMOVED: ApiMethodBillingConfigOptions - now using direct Stripe portal redirects

  # REMOVED: ApiMethodCheckPermissions - billing permission now handled in auth endpoint

  # REMOVED: ApiMethodCheckPermissionsOptions - billing permission now handled in auth endpoint


  # ----------- Deployment -----------
  ApiGatewayDeployment:
    Type: AWS::ApiGateway::Deployment
    DependsOn:
      - ApiMethodApiOptions
      - ApiMethodDel
      - ApiMethodJson
      - ApiMethodJsonOptions
      - ApiMethodAuth
      - ApiMethodAuthOptions
      - ApiMethodLlm
      - ApiMethodLlmOptions
      - ApiMethodLlmPreload
      - ApiMethodLlmPreloadOptions
      - ApiMethodRegister
      - ApiMethodRegisterOptions
      - ApiMethodDeleteTenant
      - ApiMethodDeleteTenantOptions
      - ApiMethodCreateUser
      - ApiMethodCreateUserOptions
      - ApiMethodManageOAuthScopes
      - ApiMethodManageOAuthScopesOptions
      - ApiMethodOAuthTokenExchange
      - ApiMethodOAuthTokenExchangeOptions
      - ApiMethodCheckAccountStatus
      - ApiMethodCheckAccountStatusOptions
      - ApiMethodDebitTokens
      - ApiMethodDebitTokensOptions
    Properties:
      RestApiId: !Ref ApiGateway
      StageName: !Ref Environment
      Description: !Sub 'Deployment ${AWS::StackName} - ${AWS::Region} - ${DeploymentId}'

  # Lambda Permission for API Gateway
  LambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref JsonBlockBuilderLambda
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*'

  # EC2 Instance Role
  EC2InstanceRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub 'json-blockbuilder-ec2-role-${Environment}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonS3ReadOnlyAccess
      Policies:
        - PolicyName: S3SchemaAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:PutObject
                  - s3:DeleteObject
                  - s3:ListBucket
                Resource:
                  - !Sub '${ExistingS3BucketArn}/schemas/*'
                  - !Sub '${ExistingS3BucketArn}/cache/*'
                  - !Sub '${ExistingS3BucketArn}'
        - PolicyName: DynamoDBAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - dynamodb:GetItem
                  - dynamodb:PutItem
                  - dynamodb:UpdateItem
                  - dynamodb:DeleteItem
                  - dynamodb:Query
                  - dynamodb:Scan
                Resource:
                  - !Ref ExistingFrontendUsersTableArn
                  - !Ref ExistingBillingTableArn
                  - !Sub '${ExistingBillingTableArn}/index/StripeCustomerIndex'
                  - !Ref ExistingBillingUserFromTenantTableArn
                  - !Sub '${ExistingBillingUserFromTenantTableArn}/index/UserEmailIndex'

  EC2InstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref EC2InstanceRole

  # Security Group for EC2
  EC2SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Security group for JSON Block Builder EC2 instance
      VpcId: !Ref MyVPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 8080
          ToPort: 8080
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 3030
          ToPort: 3030
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0

  # Auto Scaling Group Resources
  # Use existing subnets from parameters

  # Load Balancer Security Group
  LoadBalancerSecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      GroupDescription: Enable HTTP and HTTPS access to the Load Balancer
      VpcId: !Ref MyVPC
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 443
          ToPort: 443
          CidrIp: 0.0.0.0/0
        - IpProtocol: tcp
          FromPort: 3030
          ToPort: 3030
          CidrIp: 0.0.0.0/0
      SecurityGroupEgress:
        - IpProtocol: -1
          CidrIp: 0.0.0.0/0

  # Application Load Balancer
  ApplicationLoadBalancer:
    Type: AWS::ElasticLoadBalancingV2::LoadBalancer
    Properties:
      Name: !Sub '${AWS::StackName}-ALB'
      Scheme: internet-facing
      Type: application
      Subnets:
        - subnet-02ae9848
        - subnet-9cf794c0
      SecurityGroups:
        - !Ref LoadBalancerSecurityGroup
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-ALB'

  # Target Group (Port 8080)
  TargetGroup:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub '${AWS::StackName}-TargetGroup'
      Port: 8080
      Protocol: HTTP
      VpcId: !Ref MyVPC
      HealthCheckIntervalSeconds: 15
      HealthCheckPath: /health
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 3
      UnhealthyThresholdCount: 5  
      TargetGroupAttributes:
        - Key: slow_start.duration_seconds
          Value: '120'
        - Key: deregistration_delay.timeout_seconds
          Value: '30'
      TargetType: instance
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-TargetGroup'

  # Target Group (Port 3030 - Petstore)
  TargetGroupPetstore:
    Type: AWS::ElasticLoadBalancingV2::TargetGroup
    Properties:
      Name: !Sub '${AWS::StackName}-TargetGroupPetstore'
      Port: 3030
      Protocol: HTTP
      VpcId: !Ref MyVPC
      HealthCheckIntervalSeconds: 15
      HealthCheckPath: /
      HealthCheckProtocol: HTTP
      HealthCheckTimeoutSeconds: 5
      HealthyThresholdCount: 3
      UnhealthyThresholdCount: 5
      TargetGroupAttributes:
        - Key: slow_start.duration_seconds
          Value: '120'
        - Key: deregistration_delay.timeout_seconds
          Value: '30'
      TargetType: instance
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-TargetGroupPetstore'

  # SSL Certificate for HTTPS
  SSLCertificate:
    Type: AWS::CertificateManager::Certificate
    Properties:
      DomainName: !Ref DomainName
      SubjectAlternativeNames:
        - !Sub '*.${DomainName}'
      ValidationMethod: DNS
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-SSL-Certificate'

  # DNS Record for blockforger.zanzalaz.com pointing to ALB
  # Commenting out because in prod we point to the TLD blockforger.net, not a subdomain. creating it manually.
  #BlockforgerDNSRecord:
  #  Type: AWS::Route53::RecordSet
  #  Properties:
  #    HostedZoneId: !Ref HostedZoneId
  #    Name: !Ref DomainName
  #    Type: CNAME
  #    TTL: 300
  #    ResourceRecords:
  #      - !GetAtt ApplicationLoadBalancer.DNSName

  # HTTPS Load Balancer Listener (Port 443 -> Target 8080)
  LoadBalancerListenerHTTPS:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref TargetGroup
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Port: 443
      Protocol: HTTPS
      Certificates:
        - CertificateArn: !Ref SSLCertificate
      SslPolicy: ELBSecurityPolicy-TLS-1-2-2017-01

  # HTTPS Load Balancer Listener (Port 3030 -> Target 3030 - Petstore)
  LoadBalancerListenerHTTPSPetstore:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref TargetGroupPetstore
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Port: 3030
      Protocol: HTTPS
      Certificates:
        - CertificateArn: !Ref SSLCertificate
      SslPolicy: ELBSecurityPolicy-TLS-1-2-2017-01

  # HTTP Load Balancer Listener (Port 80 -> Target 8080)
  LoadBalancerListener:
    Type: AWS::ElasticLoadBalancingV2::Listener
    Properties:
      DefaultActions:
        - Type: forward
          TargetGroupArn: !Ref TargetGroup
      LoadBalancerArn: !Ref ApplicationLoadBalancer
      Port: 80
      Protocol: HTTP

  # Launch Template
  LaunchTemplate:
    Type: AWS::EC2::LaunchTemplate
    Properties:
      LaunchTemplateName: !Sub '${AWS::StackName}-LaunchTemplate'
      LaunchTemplateData:
        ImageId: ami-057f203c37d64cd34  # Amazon Linux 2023 kernel-6.12 AMI
        InstanceType: t4g.nano
        KeyName: !Ref EC2KeyName
        IamInstanceProfile:
          Arn: !GetAtt EC2InstanceProfile.Arn
        SecurityGroupIds:
          - !Ref EC2SecurityGroup
        UserData:
          Fn::Base64: !Sub |
            #!/bin/bash
            # Detect OS and use appropriate package manager
            if [ -f /etc/os-release ]; then
              . /etc/os-release
              OS=$ID
            else
              echo "Cannot detect OS"
              exit 1
            fi
            
            # Install git (required for cloning)
            if [ "$OS" = "ubuntu" ]; then
              apt update -y
              apt install -y git
              
              # Install Docker
              apt install -y apt-transport-https ca-certificates curl software-properties-common
              curl -fsSL https://download.docker.com/linux/ubuntu/gpg | apt-key add -
              add-apt-repository "deb [arch=arm64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
              apt update -y
              apt install -y docker-ce docker-ce-cli containerd.io
              
              # Install Node.js 18.x
              curl -fsSL https://deb.nodesource.com/setup_18.x | bash -
              apt install -y nodejs
            elif [ "$OS" = "amzn" ] || [ "$OS" = "al2023" ]; then
              # Amazon Linux 2 or 2023
              if command -v dnf &> /dev/null; then
                # Amazon Linux 2023 uses dnf
                dnf update -y
                dnf install -y git
                dnf install -y docker
                systemctl start docker
                systemctl enable docker
                
                # Install Node.js 18.x for Amazon Linux
                dnf install -y nodejs npm || {
                  # Fallback: Install Node.js from NodeSource
                  curl -fsSL https://rpm.nodesource.com/setup_18.x | bash -
                  dnf install -y nodejs
                }
              else
                # Amazon Linux 2 uses yum
                yum update -y
                yum install -y git
                yum install -y docker
                systemctl start docker
                systemctl enable docker
                
                # Install Node.js 18.x for Amazon Linux 2
                curl -fsSL https://rpm.nodesource.com/setup_18.x | bash -
                yum install -y nodejs
              fi
            else
              echo "Unsupported OS: $OS"
              exit 1
            fi
            
            systemctl start docker
            systemctl enable docker
            
            # Verify installation
            node --version
            npm --version
            npm install -g forever
            
            # Clone the repository
            git clone https://github.com/markd315/Blockforger.git /opt/json-blockbuilder
            
            cd /opt/json-blockbuilder
            
            # Switch to prod branch if environment is prod
            # Use $$ to escape CloudFormation substitution - bash will evaluate ENVIRONMENT variable at runtime
            ENVIRONMENT="${Environment}"
            if [ "$ENVIRONMENT" = "prod" ]; then
              echo "Switching to prod branch..."
              git checkout prod || echo "Warning: prod branch may not exist yet"
            fi
            
            # Install npm dependencies
            npm install
            
            # Install global npm packages
            npm install -g forever
            npm install -g browserify
            
            # Build bundle.js from main.js
            browserify public/main.js -o public/bundle.js

            # Override GOOGLE_CLIENT_ID in api-config.js with CFT param
            sed -i "s|GOOGLE_CLIENT_ID: '.*'|GOOGLE_CLIENT_ID: '${GoogleClientId}'|" public/api-config.js

            # Export environment variables for the Node process and start via forever
            export AWS_REGION=us-east-1
            export S3_BUCKET_NAME=${ExistingS3BucketName}
            export FRONTEND_USERS_TABLE_NAME=$FRONTEND_USERS_TABLE_NAME
            export BILLING_TABLE_NAME=$BILLING_TABLE_NAME
            export BILLING_USER_FROM_TENANT_TABLE_NAME=$BILLING_USER_FROM_TENANT_TABLE_NAME
            export STRIPE_INITIAL_PAYMENT_URL=${StripeInitialPaymentUrl}
            export STRIPE_CUSTOMER_PORTAL_URL=${StripeCustomerPortalUrl}
            export PAYMENT_ENABLED=${PaymentEnforced}
            export ENVIRONMENT=${Environment}

            # Start the application with forever; inject env inline to be 100% certain
            S3_BUCKET_NAME=${ExistingS3BucketName} \
            AWS_REGION=us-east-1 \
            FRONTEND_USERS_TABLE_NAME=$FRONTEND_USERS_TABLE_NAME \
            BILLING_TABLE_NAME=$BILLING_TABLE_NAME \
            BILLING_USER_FROM_TENANT_TABLE_NAME=$BILLING_USER_FROM_TENANT_TABLE_NAME \
            STRIPE_INITIAL_PAYMENT_URL=${StripeInitialPaymentUrl} \
            STRIPE_CUSTOMER_PORTAL_URL=${StripeCustomerPortalUrl} \
            PAYMENT_ENABLED=${PaymentEnforced} \
            ENVIRONMENT=${Environment} \
            forever start -c "npm start" ./

            # Debug: record env actually used at boot
            echo "S3_BUCKET_NAME=${ExistingS3BucketName}" >> /var/log/json-blockbuilder.env
            echo "ENVIRONMENT=${Environment}" >> /var/log/json-blockbuilder.env

            # Pull and run Swagger Petstore on port 3030 with QEMU emulation for ARM64
            # swaggerapi/petstore only supports linux/amd64, so we use QEMU to emulate it
            echo "========================================="
            echo "Setting up QEMU for multi-arch Docker support..."
            echo "Host architecture: $(uname -m)"
            echo "OS: $OS"
            echo "========================================="
            
            # First, ensure QEMU packages are installed (required for binfmt to work)
            echo "[1/6] Installing QEMU packages..."
            if [ "$OS" = "ubuntu" ]; then
              apt install -y qemu-user-static binfmt-support 2>&1 | tee /tmp/qemu-install.log
            elif command -v dnf &> /dev/null; then
              dnf install -y qemu-user-static 2>&1 | tee /tmp/qemu-install.log
            else
              yum install -y qemu-user-static 2>&1 | tee /tmp/qemu-install.log
            fi
            echo "QEMU installation output saved to /tmp/qemu-install.log"
            
            # Verify QEMU is available and log all found instances
            echo "[2/6] Verifying QEMU installation..."
            echo "Searching for qemu-x86_64 binaries..."
            find /usr -name "*qemu*x86*" 2>/dev/null | head -10 || echo "No QEMU x86_64 binaries found in /usr"
            find /bin -name "*qemu*x86*" 2>/dev/null | head -10 || echo "No QEMU x86_64 binaries found in /bin"
            
            QEMU_BIN=""
            if command -v qemu-x86_64-static &> /dev/null; then
              QEMU_BIN=$(command -v qemu-x86_64-static)
              echo "Found qemu-x86_64-static via PATH: $QEMU_BIN"
            elif [ -f /usr/bin/qemu-x86_64-static ]; then
              QEMU_BIN=/usr/bin/qemu-x86_64-static
              echo "Found qemu-x86_64-static at: $QEMU_BIN"
            else
              QEMU_BIN=$(find /usr -name qemu-x86_64-static 2>/dev/null | head -1)
              if [ -n "$QEMU_BIN" ]; then
                echo "Found qemu-x86_64-static via search: $QEMU_BIN"
              else
                echo "ERROR: qemu-x86_64-static not found after installation"
                echo "Listing all qemu binaries:"
                find /usr /bin -name "*qemu*" 2>/dev/null | head -20
                exit 1
              fi
            fi
            echo "Using QEMU binary: $QEMU_BIN"
            ls -lh "$QEMU_BIN" || echo "WARNING: Cannot stat QEMU binary"
            
            # Check current binfmt status
            echo "[3/6] Checking current binfmt status..."
            if [ -d /proc/sys/fs/binfmt_misc ]; then
              echo "binfmt_misc directory exists"
              echo "Current binfmt registrations:"
              ls -la /proc/sys/fs/binfmt_misc/ 2>&1 || echo "Cannot list binfmt_misc"
              if [ -f /proc/sys/fs/binfmt_misc/qemu-x86_64 ]; then
                echo "qemu-x86_64 already registered:"
                cat /proc/sys/fs/binfmt_misc/qemu-x86_64 2>&1 || echo "Cannot read registration"
              else
                echo "qemu-x86_64 not yet registered"
              fi
            else
              echo "WARNING: /proc/sys/fs/binfmt_misc does not exist"
            fi
            
            # Install binfmt support using tonistiigi/binfmt (maintained by Docker core engineer)
            echo "[4/6] Registering binfmt for amd64 emulation..."
            echo "Running: docker run --rm --privileged tonistiigi/binfmt --install amd64"
            docker run --rm --privileged tonistiigi/binfmt --install amd64 2>&1 | tee /tmp/binfmt-install.log || {
              echo "WARNING: binfmt setup failed for amd64, trying 'all' architectures..."
              echo "Running: docker run --rm --privileged tonistiigi/binfmt --install all"
              docker run --rm --privileged tonistiigi/binfmt --install all 2>&1 | tee /tmp/binfmt-install-all.log || {
                echo "ERROR: binfmt setup failed completely"
                echo "Checking Docker logs..."
                docker logs $(docker ps -a -q -f ancestor=tonistiigi/binfmt | head -1) 2>&1 | tail -20 || echo "No binfmt container logs"
                exit 1
              }
            }
            echo "binfmt installation output saved to /tmp/binfmt-install*.log"
            
            # Verify binfmt registration worked
            echo "[5/6] Verifying binfmt registration..."
            sleep 1  # Give binfmt a moment to register
            if [ -f /proc/sys/fs/binfmt_misc/qemu-x86_64 ]; then
              echo "✓ binfmt registration verified: /proc/sys/fs/binfmt_misc/qemu-x86_64 exists"
              echo "Registration details:"
              cat /proc/sys/fs/binfmt_misc/qemu-x86_64 2>&1 | head -5
            else
              echo "✗ WARNING: binfmt registration may not have worked"
              echo "Available binfmt handlers:"
              ls -la /proc/sys/fs/binfmt_misc/ 2>&1 | grep -v "^total" | grep -v "^d" || echo "Cannot list handlers"
            fi
            
            # Pull and run Petstore with amd64 emulation using QEMU
            echo "[6/6] Pulling and starting Petstore container..."
            echo "Pulling swaggerapi/petstore (amd64, will emulate on ARM64)..."
            docker pull --platform linux/amd64 swaggerapi/petstore 2>&1 | tail -5
            
            # Run container - QEMU emulation is handled automatically by binfmt
            echo "Starting Petstore container with amd64 emulation..."
            echo "Command: docker run -d --name petstore --platform linux/amd64 ..."
            CONTAINER_OUTPUT=$(docker run -d --name petstore \
              -e SWAGGER_HOST=http://petstore.swagger.io \
              -e SWAGGER_URL=http://localhost \
              -e SWAGGER_BASE_PATH=/v2 \
              -p 3030:8080 \
              --restart unless-stopped \
              --platform linux/amd64 \
              swaggerapi/petstore 2>&1)
            CONTAINER_EXIT_CODE=$?
            
            if [ $CONTAINER_EXIT_CODE -eq 0 ]; then
              CONTAINER_ID=$(echo "$CONTAINER_OUTPUT" | head -1)
              echo "✓ Container started: $CONTAINER_ID"
              sleep 2
              echo "Container status:"
              docker ps -a --filter "id=$CONTAINER_ID" --format "table {{.ID}}\t{{.Status}}\t{{.Names}}"
              
              if docker ps --filter "id=$CONTAINER_ID" --format "{{.Status}}" | grep -q "Up"; then
                echo "✓ Container is running!"
              else
                echo "✗ Container is not running. Checking logs..."
                docker logs "$CONTAINER_ID" 2>&1 | tail -20
                echo "Checking container exit code:"
                docker inspect "$CONTAINER_ID" --format='{{.State.ExitCode}}' || echo "Cannot get exit code"
              fi
            else
              echo "✗ ERROR: Petstore container failed to start"
              echo "Exit code: $CONTAINER_EXIT_CODE"
              echo "Output: $CONTAINER_OUTPUT"
              echo ""
              echo "Diagnostics:"
              echo "1. binfmt status:"
              ls -la /proc/sys/fs/binfmt_misc/ 2>&1 | head -10 || echo "binfmt_misc not accessible"
              echo "2. QEMU binary check:"
              ls -lh "$QEMU_BIN" 2>&1 || echo "QEMU binary not accessible"
              echo "3. Docker info:"
              docker info 2>&1 | grep -i "architecture\|platform" || echo "Cannot get Docker info"
              exit 1
            fi
            echo "========================================="
            
            # Extract table names from ARNs before creating systemd service
            FRONTEND_USERS_TABLE_NAME=$(echo "${ExistingFrontendUsersTableArn}" | awk -F'/' '{print $NF}')
            BILLING_TABLE_NAME=$(echo "${ExistingBillingTableArn}" | awk -F'/' '{print $NF}')
            BILLING_USER_FROM_TENANT_TABLE_NAME=$(echo "${ExistingBillingUserFromTenantTableArn}" | awk -F'/' '{print $NF}')
            
            # Create environment variable profile script for ubuntu user (for shell access/debugging)
            # These will be available when you SSH in and use printenv
            cat > /etc/profile.d/json-blockbuilder-env.sh << PROFILEEOF
            # JSON Block Builder Environment Variables
            export AWS_REGION=us-east-1
            export S3_BUCKET_NAME=${ExistingS3BucketName}
            export FRONTEND_USERS_TABLE_NAME=$FRONTEND_USERS_TABLE_NAME
            export BILLING_TABLE_NAME=$BILLING_TABLE_NAME
            export BILLING_USER_FROM_TENANT_TABLE_NAME=$BILLING_USER_FROM_TENANT_TABLE_NAME
            export STRIPE_INITIAL_PAYMENT_URL=${StripeInitialPaymentUrl}
            export STRIPE_CUSTOMER_PORTAL_URL=${StripeCustomerPortalUrl}
            export PAYMENT_ENABLED=${PaymentEnforced}
            export ENVIRONMENT=${Environment}
            PROFILEEOF
            chmod 644 /etc/profile.d/json-blockbuilder-env.sh
            
            # NOTE: We intentionally do NOT start via systemd here to avoid conflicts.
            # A systemd unit can be added later if desired, but manual forever start is the source of truth.
        TagSpecifications:
          - ResourceType: instance
            Tags:
              - Key: Name
                Value: !Sub '${AWS::StackName}-Instance'

  # Auto Scaling Group
  AutoScalingGroup:
    Type: AWS::AutoScaling::AutoScalingGroup
    Properties:
      AutoScalingGroupName: !Sub '${AWS::StackName}-ASG'
      VPCZoneIdentifier:
        - subnet-02ae9848
        - subnet-9cf794c0
      LaunchTemplate:
        LaunchTemplateId: !Ref LaunchTemplate
        Version: !GetAtt LaunchTemplate.LatestVersionNumber
      MinSize: 1
      MaxSize: 10
      DesiredCapacity: 1
      TargetGroupARNs:
        - !Ref TargetGroup
        - !Ref TargetGroupPetstore
      HealthCheckType: ELB
      HealthCheckGracePeriod: 300
      Tags:
        - Key: Name
          Value: !Sub '${AWS::StackName}-ASG-Instance'
          PropagateAtLaunch: true

  # CloudWatch Alarms for Auto Scaling
  CPUUtilizationAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: "Scale up if CPU utilization is high"
      MetricName: CPUUtilization
      Namespace: AWS/EC2
      Statistic: Average
      Period: 300
      EvaluationPeriods: 2
      Threshold: !Ref ScaleUpThreshold
      ComparisonOperator: GreaterThanOrEqualToThreshold
      AlarmActions:
        - !Ref ScaleUpPolicy
      Dimensions:
        - Name: AutoScalingGroupName
          Value: !Ref AutoScalingGroup

  ScaleUpPolicy:
    Type: AWS::AutoScaling::ScalingPolicy
    Properties:
      AdjustmentType: ChangeInCapacity
      AutoScalingGroupName: !Ref AutoScalingGroup
      Cooldown: 300
      ScalingAdjustment: 1

  ScaleDownPolicy:
    Type: AWS::AutoScaling::ScalingPolicy
    Properties:
      AdjustmentType: ChangeInCapacity
      AutoScalingGroupName: !Ref AutoScalingGroup
      Cooldown: 300
      ScalingAdjustment: -1

  LowCPUUtilizationAlarm:
    Type: AWS::CloudWatch::Alarm
    Properties:
      AlarmDescription: "Scale down if CPU utilization is low"
      MetricName: CPUUtilization
      Namespace: AWS/EC2
      Statistic: Average
      Period: 300
      EvaluationPeriods: 2
      Threshold: !Ref ScaleDownThreshold
      ComparisonOperator: LessThanOrEqualToThreshold
      AlarmActions:
        - !Ref ScaleDownPolicy
      Dimensions:
        - Name: AutoScalingGroupName
          Value: !Ref AutoScalingGroup

  ApiGatewayExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: apigateway.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: ApiGatewayInvokeLambda
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource: !GetAtt JsonBlockBuilderLambda.Arn

  # EventBridge Rule for daily billing at midnight Eastern
  DailyBillingRule:
    Type: AWS::Events::Rule
    Properties:
      Name: !Sub '${AWS::StackName}-daily-billing'
      Description: 'Trigger daily billing process at midnight Eastern Time'
      ScheduleExpression: 'cron(0 5 * * ? *)'  # 5 AM UTC = midnight Eastern
      State: ENABLED
      Targets:
        - Arn: !GetAtt JsonBlockBuilderLambda.Arn
          Id: 'DailyBillingTarget'
          Input: !Sub '{"type": "bill", "body": {"passkey": "${BillingPasskey}"}}'

  # Permission for EventBridge to invoke Lambda
  EventBridgeLambdaPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref JsonBlockBuilderLambda
      Action: lambda:InvokeFunction
      Principal: events.amazonaws.com
      SourceArn: !GetAtt DailyBillingRule.Arn

  # SQS Queue for Stripe webhook events (now the main processing queue)
  StripeWebhookQueue:
    Type: AWS::SQS::Queue
    Properties:
      QueueName: !Sub 'stripe-webhook-queue-${Environment}'
      MessageRetentionPeriod: 1209600  # 14 days
      VisibilityTimeout: 30

  # EventBridge Rule for Stripe webhook events - now routes to SQS instead of Lambda
  StripeRule:
    Type: AWS::Events::Rule
    Properties:
      Name: Stripe-Rule
      EventPattern: >-
        {"source":[{"prefix":"aws.partner/stripe.com"}],"detail-type":["checkout.session.completed"]}
      State: ENABLED
      Description: ''
      EventBusName: !Sub 'arn:aws:events:${AWS::Region}:${AWS::AccountId}:event-bus/aws.partner/stripe.com/ed_61TX2cVJn3QVhT4Aw16TTLfQIwSQi86GCyns769PMFlY'
      Targets:
        - Id: StripeSQSTarget
          Arn: !GetAtt StripeWebhookQueue.Arn

  # REMOVED: StripeWebhookLambdaPermission - EventBridge now routes to SQS instead of Lambda directly 

  # Permission for EventBridge to send messages to SQS Queue
  StripeWebhookQueuePolicy:
    Type: AWS::SQS::QueuePolicy
    Properties:
      Queues:
        - !Ref StripeWebhookQueue
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: events.amazonaws.com
            Action: sqs:SendMessage
            Resource: !GetAtt StripeWebhookQueue.Arn

  # SQS Event Source Mapping for Queue to StripeWebhookLambda
  StripeQueueEventSourceMapping:
    Type: AWS::Lambda::EventSourceMapping
    Properties:
      EventSourceArn: !GetAtt StripeWebhookQueue.Arn
      FunctionName: !Ref StripeWebhookLambda
      BatchSize: 1
      MaximumBatchingWindowInSeconds: 0

Outputs:
  ApiGatewayUrl:
    Description: API Gateway URL
    Value: !Sub 'https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/${Environment}/api'
  
  S3BucketName:
    Description: S3 Bucket for schemas (existing)
    Value: !Ref ExistingS3BucketArn
  
  
  #DynamoDBTableName:
   # Description: DynamoDB Table Name
    #Value: !Ref FrontendUsersTable
  
  LambdaDeploymentBucketName:
    Description: S3 Bucket for Lambda deployment package
    Value: !Ref ExistingLambdaDeploymentBucket

  # CloudFront outputs removed - not using it yet

  # StaticContentBucketName removed - bucket not managed by this stack

  ApplicationLoadBalancerDNS:
    Description: Application Load Balancer DNS Name
    Value: !GetAtt ApplicationLoadBalancer.DNSName

  ApplicationLoadBalancerHTTPSURL:
    Description: Application Load Balancer HTTPS URL
    Value: !Sub 'https://${ApplicationLoadBalancer.DNSName}'

  SSLCertificateArn:
    Description: SSL Certificate ARN
    Value: !Ref SSLCertificate

  AutoScalingGroupName:
    Description: Auto Scaling Group Name
    Value: !Ref AutoScalingGroup 
